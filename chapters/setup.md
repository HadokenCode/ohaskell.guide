# Приготовимся

Мы не можем начать изучение языка без испытательного полигона. Установим Haskell.

Сделать это можно несколькими способами, мы выберем самый удобный. Называется он [The Haskell Tool Stack](http://haskellstack.org/). Эта утилита &mdash; всё, что вам понадобится для работы с Haskell.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Haskell &mdash; кроссплатформенный язык, работающий и в OS X, и в Linux, и даже в Windows. Однако в 2008 году я навсегда покинул мир Windows, поэтому все последующие примеры взаимодействия с командной строкой подразумевают Unix-way. Вся конфигурация и примеры кода опробованы мною на OX S Yosemite.
</span></div>

## Устанавливаем

Идём [сюда](http://docs.haskellstack.org/en/stable/install_and_upgrade.html) и скачиваем архив для нужной нам ОС. Распаковываем архив &mdash; и перед нами утилита под названием `stack`. Для удобства располагаем её в каком-нибудь каталоге, доступном в `PATH`. Рекомендованный путь &mdash; `~/.local/bin/`.

Если же вы живёте в мире Mac и пользуетесь [Homebrew](http://brew.sh/) &mdash; вам ещё проще. Делаете:

```bash
$ brew update
$ brew install haskell-stack
```

Всё.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
На момент написания книги я использовал `stack` версии 1.0.2. Если у вас более старая версия &mdash; непременно обновитесь. Если же более новая &mdash; у вас теоретически что-нибудь может работать не совсем так, как описано ниже, поскольку `stack` активно разивается, добавляются новые возможности, может быть где и поломают обратную совместимость.
</span></div>

Главное (но не единственное), что умеет делать `stack`, это:

1. Разворачивать инфраструктуру.
2. Собирать проекты.
3. Устанавливать библиотеки.

Haskell-инфраструктура &mdash; экосистема, краеугольным камнем которой является компилятор GHC (Glasgow Haskell Compiler). Как было сказано ранее, Haskell &mdash; это компилируемый язык: приложение представляет собой обыкновенный исполняемый файл.

Haskell-проект &mdash; среда для создания приложений и библиотек.

Haskell-библиотеки &mdash; готовые решения, спасающие нас от изобретения велосипедов.

## Разворачиваем инфраструктуру

Делаем:

```bash
$ stack setup
```

В результате на ваш компьютер будет установлена инфраструктура последней стабильной версии. Жить всё это хозяйство будет в только что созданном каталоге `~/.stack/`. Именно поэтому устанавливать инфраструктуру для последующих Haskell-проектов вам уже не придётся: единожды развернули, используем всегда. Пока вам не нужно знать об устройстве этой инфраструктуры, воспринимайте её как данность: теперь на вашем компьютере живёт Haskell.

## Hi World

Создадим наш первый Haskell-проект:

```bash
$ stack new real
```

Здесь `real` &mdash; название проекта. В результате будет создан каталог `real`, внутри которого мы увидим это:

```bash
.
├── LICENSE
├── Setup.hs
├── app
│   └── Main.hs <- Главный модуль
├── real.cabal  <- Сборочный файл
├── src
│   └── Lib.hs  <- Вспомогательный модуль
├── stack.yaml
└── test
    └── Spec.hs
```

О содержимом проекта вам пока знать не нужно, просто соберём его командой:

```bash
$ stack install
```

Запомните эту команду, мы будем использовать её постоянно. В результате её выполнения появится файл `real-exe`. А поскольку скопирован он будет в упомянутый выше каталог `~/.local/bin/`, мы сможем сразу запустить программу:

```bash
$ real-exe
someFunc
```

Вот мы и создали Haskell-проект и запустили нашу первую программу, выведшую строку `"someFunc"`. Но как же это работает? Пришла пора познакомится с фундаментальной единицей проекта &mdash; модулем.

## Модули: первый взгляд

Настоящие проекты никогда не состоят из одного-единственного файла. Познакомимся с модулями.

Файлы, содержащие Haskell-код &mdash; это и есть модули. Один файл &mdash; один модуль. В Haskell нет заголовочных файлов: каждый из модулей рассматривается как самостоятельная единица проекта, содержащая в себе разные полезные вещи. А чтобы воспользоваться этими вещами, необходимо один модуль импортировать в другой.

Откроем модуль `src/Lib.hs`:

```haskell
module Lib
    ( someFunc
    ) where

someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

В первой строке объявлено, что имя этого модуля &mdash; `Lib`. Далее, в круглых скобках упомянуто содержимое данного модуля, а именно имя функции `someFunc`. Затем, после ключевого слова `where`, мы видим определение функции `someFunc`. Пока вам не нужно знать о синтаксисе данной конструкции, в следующих главах мы разберём его тщательнейшим образом.

Как вы уже поняли, расширение `.hs` &mdash; стандартное расширения для модулей.

Теперь откроем модуль `app/Main.hs`:

```haskell
module Main where

import Lib      -- Импортируем модуль Lib...

main :: IO ()
main = someFunc -- Используем его содержимое...
```

Это &mdash; модуль `Main`, главный модуль нашего приложения, ведь именно здесь определена функция `main`. С помощью директивы `import` мы включаем сюда модуль `Lib` и можем работать с содержимым этого модуля.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Запомните модуль `Main`, с ним мы будем работать чаще всего. Все примеры исходного кода, которые вы увидите на страницах этой книги, живут именно в модуле `Main`, если не оговорено обратное.
</span></div>

## Имена модулей

Есть два правила.

Во-первых, имя модуля должно начинаться с большой буквы.

Во-вторых, имя модуля должно совпадать с именем соответствующего ему файла. Именно поэтому файл, содержащий модуль `Main`, назван `Main.hs`. Это, кстати, очень удобно, помогает избегать путаницы.

Всё. В будущих главах вы узнаете о модулях кое-что ещё, но пока достаточно этого. Теперь пора познакомится с пакетами, ведь мы будем использовать их в наших проектах постоянно.

