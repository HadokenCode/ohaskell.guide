# Лямбда-функция

Теперь мы должны познакомится с важной концепцией &mdash; c лямбда-функцией. Потому что именно с неё всё и началось.

## Мать функционального программирования

В далёких 1930-х молодой американский математик [Алонзо Чёрч](https://ru.wikipedia.org/wiki/%D0%A7%D1%91%D1%80%D1%87,_%D0%90%D0%BB%D0%BE%D0%BD%D0%B7%D0%BE) задался вопросом о том, что значит &laquo;вычислить&raquo; что-то. Плодом его размышлений явилась система для формализации понятия &laquo;вычисление&raquo;, и назвал он её &laquo;лямбда-исчислением&raquo; (англ. lambda calculus, по имени греческой буквы `λ`).

В основе этой системы лежит лямбда-функция, и именно её можно считать &laquo;матерью функционального программирования&raquo; в целом и Haskell в частности. Далее буду называть её ЛФ.

В отношении ЛФ можно смело сказать: &laquo;Всё гениальное просто&raquo;. Идея ЛФ столь полезна именно потому, что она предельно проста. ЛФ &mdash; это анонимная функция. Вот как она выглядит в Haskell:

```haskell
\x -> x * x
```

Обратный слэш в начале &mdash; признак ЛФ. Сравните с математической формой:

```haskell
λx . x * x
```

Похоже, не правда ли? Воспринимайте обратный слэш в определении ЛФ как спинку буквы `λ`.

ЛФ представляет собой простейший вид функции, эдакая функция, раздетая догола. У неё забрали не только объявление, но и имя, оставив лишь необходимый минимум в виде имён аргументов и внутреннего выражения. Алонзо Чёрч понял: чтобы применить функцию, нам вовсе необязательно именовать её.































Вспомним упомянутое в предыдущей главе определение математической функции:

> **Функция - это описание зависимости чего-то от чего-то.**

Более того, как мы узнали в прошлой главе, чистые функции в Haskell - это просто (возвращаемые ими) значения. Однако в языке C (и подобных ему языках) функция никогда не ассоциировалась с таким определением. Напротив, функция там есть ни что иное, как подпрограмма, а имя функции есть ни что иное, как указатель на первую инструкцию этой подпрограммы.

Кроме того, функция в языке C является глобальной в рамках текущей единицы трансляции. И поэтому вызов функции - это своего рода глобальный `goto` в её тело, с последующим возвратом из него. Именно поэтому функция в языке C не может быть безымянной, потому что иначе её невозможно было бы вызвать.

λ-функция - совсем другой зверь.

## Что это такое

В основе λ-функций лежит λ-исчисление, названное так по имени красивой греческой буквы. У λ-исчисления довольно-таки долгая академическая история, но нас с вами интересует практическая сторона, поэтому сразу приведу пример.

Помните нашу функцию `f1`, возвращающую квадрат своего аргумента? Если мы даём ей на вход число 5, то на выходе получаем 25. Схематично это можно отразить так:

```haskell
5 -> (x * x) -> 25
```

А теперь вопрос: как такую функцию описать *формально*? Вот тут-то на сцену и выходит λ-исчисление, ибо оно как раз и предлагает формализованный способ записи функции. Для функции `f1` эта запись будет такой:

```haskell
λx.x * x 
```

Буква λ - это признак λ-функции. А читать это выражение следует так: "λ-функция от одного аргумента x, возвращающая результат умножения этого аргумента на самого себя".

Разделителем здесь является точка. Выражение слева от этой точки - список аргументов (в данном случае он один), а выражение справа от неё - тело функции:

```
λ                  x         .  x * x
признак λ-функции  аргумент     тело
```

Простое и элегантное описание, ничего лишнего, даже имени. Особенностью λ-функции является её безымянность, ведь имя ей не нужно. И это принципиально отличает её от обыкновенной функции.

## Как это выглядит в коде

λ-функции присутствуют во многих языках, но в Haskell вид λ-выражения максимально приближен к математическому. Сравните:

```haskell
λx .  x * x  -- Математическая форма
\x -> x * x  -- Haskell-форма
```

Прямое сходство. Даже `\` вначале подходит как нельзя лучше: рассматривайте его как "спинку" буквы λ. Единственное отличие - замена точки стрелочкой.

А теперь возникает резонный вопрос: как мы можем вызвать такую функцию? Вероятно, ответ удивит вас, но λ-функции не вызывают. Впрочем, это лишь игра слов. Вернёмся на минутку в математику.

Идея λ-функции базируется на математическом принципе "аппликации" (application), или "применения". λ-функцию не вызывают с аргументом, а применяют (апплицируют) её к аргументу. Поэтому запись вида:

```haskell
f x
```

принято читать так: "Применение функции `f` к аргументу `x`".

Вот как это выглядит в Haskell:

```haskell
(\x -> x * x) 5
```

λ-выражение, находящееся в скобках, порождает λ-функцию, которая сразу же применяется к аргументу 5 и возвращает 25.

## Множество аргументов

λ-функция может применяться и к нескольким аргументам. Вот функция, возвращающая результат умножения первого значения на второе:

```haskell
main =
    print (f 5 6)
    where f = \arg1 arg2 -> arg1 * arg2
```

Между `\` и стрелочкой идёт список имён аргументов функции:

```haskell
\                  arg1 arg2         ->  arg1 * arg2
признак λ-функции  имена аргументов      тело функции
```

## Какая от них польза

В языке C при работе с функцией принята стандартная последовательность из трёх шагов:

1. объявление,
2. определение,
3. вызов.

Например:

```c
int sq( int i ) {
    return i * i;
}

int main() {
    printf( "%d", sq( 5 ) );
}
```

Мы готовим нашу "глобальную подпрограмму", а потом заходим в неё через вызов.

А вот как это выглядит в Haskell:

```haskell
main = print ((\x -> x * x) 5)
```

Мы ничего не готовим заранее. Напротив, мы создаём функцию как значение, локально и непосредственно перед использованием. Создаём - и тут же применяем её к аргументу `5`. Для простоты мы можем ввести пояснительное выражение для нашей функции:

```haskell
main =
    print (f 5)
    where f = \x -> x * x
```

Одно из преимуществ λ-функции как раз и заключается в её локальности. Зачем нам заранее объявлять и определять функцию, если мы можем создать и сразу использовать её непосредственно в том месте, где она нужна? Впрочем, если λ-функция используется в нескольких местах, мы можем, во избежание дубляжа, определить её глобально, связав с некоторым именем. Например так:

```haskell
f = \x -> x * x

main = print ((f 5) + (f 6))
```

Выражение `f` теперь равно нашей λ-функции, и теперь мы можем многократно применять это выражение к различным аргументам.

## В сухом остатке

1. λ-функция (далее ЛФ) - это анонимное отражение зависимости чего-то от чего-то.
2. Чаще всего ЛФ создаётся локально и сразу же применяется к некоторым аргументам.

