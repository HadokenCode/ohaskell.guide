----
title: Список
prevChapter: /ru/about-lists/index.html
nextChapter: /ru/about-lists/ranges.html
----

Список в Haskell - это структура данных, представляющая собою набор значений одного типа. Например, список из трёх целых чисел выглядит так:

```haskell
[1, 2, 3]
```

а список из двух значений типа `Double` - так:

```haskell
[1.3, 45.7899]
```

а вот и список из одного символа:

```haskell
['H']
```

Конечно, список может быть и пустым:

```haskell
[]
```

Элементами списка могут быть значения любого типа, в том числе и другие списки (списки списков - вещь в Haskell-коде весьма распространённая).

## Простейшие действия

Если списки создаются - значит это кому-нибудь нужно. Вот функция, формирующая список из трёх строк:

```haskell
listOfNames :: String -> [String]
listOfNames prefix =
    [prefix ++ "John", prefix ++ "Anna", prefix ++ "Andrew"]

main = print $ listOfNames "Dear "
```

Результат:

```bash
["Dear John","Dear Anna","Dear Andrew"]
```

Обратите внимание на объявление этой функции:

```haskell
listOfNames :: String -> [String]
```

Тип `[String]` - это список строк. А, например, список символов объявляется как `[Char]`. Кстати, строка - это и есть список символов, то есть тип `String` эквивалентен типу `[Char]`. Поэтому данное объявление можно переписать и так:

```haskell
listOfNames :: String -> [[Char]]  -- Возвращает список списков символов.
```

Вот так можно узнать размер списка:

```haskell
main = print $ length listOfAnimals
    where listOfAnimals = ["Bear", "Tiger", "Lion", "Wolf"]
```

А так можно узнать, присутствует ли заданное значение в списке:

```haskell
thisIsAWildAnimal :: String -> Bool
thisIsAWildAnimal name = name `elem` wildAnimals
    where wildAnimals = ["Bear", "Tiger", "Lion", "Wolf"]

main = putStrLn $ if thisIsAWildAnimal "Cat" then "Yes!" else "No!"
```

Здесь стандартная функция `elem`, записанная в инфиксной форме (то есть между двумя своими аргументами), проверяет наличие строки `"Cat"` в списке диких животных.

Разумеется, со списком можно делать огромное множество различных действий. Все они включены в .

## Неизменность списка

Как вы знаете, все значения в Haskell неизменны, как Египетские пирамиды. Списки - не исключение: мы не можем изменить список, мы можем лишь создать на его основе новый список. Например:

```haskell
addToFront :: String -> [String] -> [String]
addToFront newHost listOfHosts = newHost : listOfHosts

main = print $ "124.67.54.90" `addToFront` listOfHosts
    where listOfHosts = ["45.67.78.89", "123.45.65.54"]
```

Вывод:

```bash
["124.67.54.90","45.67.78.89","123.45.65.54"]
```

Оператор `:` добавляет значение, являющееся левым операндом, в начало списка, являющегося правым операндом:

```haskell
newHost : listOfHosts
```

С концептуальной точки зрения функция `addToFront` добавила новый адрес в начало переданного ей списка. Но в действительности никакого добавления не произошло: функция просто взяла значение `newHost` и список `listOfHosts` и создала на их основе новый список, содержащий уже три адреса вместо двух.

## Действия над элементами

Мы создаём список для того, чтобы что-то делать с его элементами. Например, такая функция:

```haskell
nonEmptyNamesFrom :: [String] -> [String]
nonEmptyNamesFrom aList =
    filter nonEmptyName aList -- Отфильтруй все непустые значения.
    where nonEmptyName = not . null

main = print $ nonEmptyNamesFrom names
    where names = ["John", "", "Ann"]
```

На выходе получим ожидаемый список из двух имён, ведь второе по счёту было пустым. Стандартная функция `filter` последовательно применяет предикат `nonEmptyName` к каждой строке в списке и конструирует новый список лишь из тех строк, которые удовлетворяют данному предикату. В качестве предиката выступает композиция функций. Эта композиция применяется к одной строке и возвращает `True` в том случае, если эта строка не `null` (то есть непустая). Обратите внимание, мы вновь использовали короткую форму записи функции `nonEmptyName`, опустив имя аргумента:

```haskell
    where nonEmptyName = not . null
```

хотя могли бы написать и так:

```haskell
    where nonEmptyName aName = not . null $ aName
```

## Сворачивание

Об этом механизме я не могу промолчать, уж очень он занимательный и полезный. Речь идёт о сворачивании (folding) списка. Суть его очень проста и элегантна, и поэтому сворачивание очень часто используется на практике.

Сворачивание - это процесс превращения всех элементов списка в одно значение. Сразу пример:

```haskell
main =
    putStrLn $ foldl (++) "http" ["://", "www", ".", "google.com"]
```

Вывод будет следующим:

```bash
http://www.google.com
```

Стандартная функция `foldl` сворачивает список слева (название собрано из слов "fold left"). Рассмотрим, как же она работает.

Для сворачивания элементов используется бинарная функция, в данном случае оператор `(++)`. На первом шаге функция `foldl` берёт начальное значение `"http"` и первый элемент `"://"`, а затем применяет к ним оператор конкатенации. В результате получается строка `"http://"`. На втором шаге оператор конкатенации применяется уже к этой строке и ко второму элементу `"www"`, в результате чего получаем `"http://www"`. На третьем шаге складываем эту строку с третьим элементом `"."`, получив `"http://www."`. И на последнем шаге складываем получившееся с четвёртым элементом, и вот перед нами полная строка `"http://www.google.com"`. Таким образом, функция `foldl` постепенно скомкала (свернула) все строки в одну.

Впрочем, вы можете увидеть все эти шаги воочию, достаточно воспользоваться стандартной функцией `scanl`:

```haskell
main =
    print $ scanl (++) "http" ["://", "www", ".", "google.com"]
```

Результат будет таким:

```bash
["http","http://","http://www","http://www.","http://www.google.com"]
```

Функция `scanl` выступает в роли эдакого рентгена для функции `foldl`, показывая внутреннюю работу последней: в возвращённом списке строк мы видим, как постепенно сворачивается наш изначальный список.

Разумеется, сворачивать список можно не только слева, но и справа. Для этого, как вы уже догадались, следует использовать функцию `foldr`:

```haskell
main =
    putStrLn $ foldr (++) ".com" ["http", "://", "www", ".", "google"]
```

Результат будет таким же, мы просто свернули строки справа, о чём нам может поведать функция `scanr`:

```haskell
main =
    print $ scanr (++) ".com" ["http", "://", "www", ".", "google"]
```

Вывод:

```bash
["http://www.google.com","://www.google.com","www.google.com",".google.com","google.com",".com"]
```

Взгляните на этот список справа налево - и вы сразу поймёте, *как* происходило сворачивание на этот раз. Кстати, если вам не нужно начальное значение, на помощь придут функции `foldl1` и `foldr1`. Да, название не очень, но уж какое есть. Этим функциям не требуется начальное значение, они сразу же начинают работать с элементами списка. Упростим наш первый пример:

```haskell
main =
    putStrLn $ foldl1 (++) ["http", "://", "www", ".", "google", ".com"]
```

Таким образом, механизм сворачивания даёт нам простой и очень элегантный способ объединения элементов списка в единое значение.

Вот и всё, что хотелось рассмотреть. Помимо функций, рассмотренных выше, в стандартной библиотеке Haskell присутствуют и многие другие вкусности для работы с элементами (проверки, замены, сортировки, перестановки и тому подобное).

## В сухом остатке

1. Список - это набор значений одного типа.
2. Мы не можем изменить уже созданный список, мы можем лишь создать на его основе другой список.
3. С элементами списка можно совершать различные манипуляции.












----
title: Генераторы списков
prevChapter: /ru/about-lists/tuples.html
nextChapter: /ru/about-user-types/index.html
----

Понятие "list comprehension" в русскоязычной документации чаще всего переводится как "генератор списка". Строго говоря, это не лучший перевод, но я не смог подобрать ничего лучшего.

Речь пойдёт об одной хитрой конструкции, предназначенной для прохода по элементам списка(ов) и применения к ним некоторых действий, в результате чего будет создан (сгенерирован) новый список. Да-да, это похоже на уже известные нам функции `map` и `filter`, однако есть некоторые дополнительные вкусности.

## Хитрый список

Вот как это выглядит:

```haskell
import Data.Char

main = print [toUpper c | c <- "http"]
```

На выходе получим:

```bash
"HTTP"
```

Рассмотрим поближе:

```haskell
[toUpper c | c <- "http"]
```

Мы видим квадратные скобки... То есть перед нами список? Ну почти. Перед нами - генератор списка. Скелет такой конструкции можно представить так:

```
[OPERATION ELEM | ELEM <- LIST]
```

где `LIST` - список, `ELEM` - элемент этого списка, а `OPERATION` - функция, применяемая к каждому элементу. Мы говорим: "Возьми список `LIST`, последовательно пройдись по всем его элементам и примени к каждому из них функцию `OPERATION`". В результате значения, возвращаемые функцией `OPERATION`, породят новый список.

В данном случае мы пройдём по всем символам строки `http` и применим к каждому из её символов функцию `toUpper`, которая в свою очередь переведёт этот символ в верхний регистр. В результате мы получим новую строку `"HTTP"`.

## Добавляем предикат

Мы можем добавить предикат в эту конструкцию. Тогда её скелет станет таким:

```
[OPERATION ELEM | ELEM <- LIST, PREDICATE]
```

В этом случае мы говорим: "Возьми список `LIST`, последовательно пройдись по всем его элементам и примени функцию `OPERATION` только к тем элементам, которые удовлетворят предикату `PREDICATE`".

Например:

```haskell
import Data.Char

main = print [toUpper c | c <- "http", c == 't']
```

На выходе будет:

```bash
"TT"
```

Мы прошлись по всем четырём символам строки `http`, но функция `toUpper` была применена только к тем символам, которые удовлетворили предикату `c == 't'`. Именно поэтому на выходе мы получили строку лишь из этих двух символов.

Предикатов, кстати, может быть несколько. Например, так:

```haskell
import Data.Char

main = print [toUpper c | c <- "http", c /= 'h', c /= 'p']
```

Вывод в этом случае будет таким же:

```bash
"TT"
```

Здесь два предиката, `c /= 'h'` и `c /= 'p'`. Они соединяются в единый предикат через логическое "И", поэтому мы можем написать и так:

```haskell
[toUpper c | c <- "http", c /= 'h' && c /= 'p']
```

Результат будет таким же.

Обратите внимание на комбинацию символов `/=`. Это функция проверки на неравенство, аналог оператора `!=` в языке C. Кстати, он тоже носит математический окрас. Сравните:

```
/=   -- Haskell-форма
≠    -- математическая форма
```

Симпатично, не правда ли? Прямое сходство, мы лишь передвинули перечеркивающую косую палочку.

## Больше списков

Мы можем использовать генератор для совместной работы с несколькими списками. Скелет в этом случае будет таким:

```
[OPERATION_with_ELEMs | ELEM1 <- LIST1, ..., ELEMN <- LISTN ]
```

Здесь мы работаем сразу с `N` списками, а `OPERATION_with_ELEMs` представляет собой функцию, в которую передаются все элементы наших списков. Например:

```haskell
main =
    print [prefix ++ name | name <- names, prefix <- namePrefix]
    where names = ["James", "Victor", "Denis", "Michael"]
          namePrefix = ["Mr. "]
```

На выходе получим:

```bash
["Mr. James","Mr. Victor","Mr. Denis","Mr. Michael"]
```

Мы последовательно прошлись по всем элементам списков `names` и `namePrefix`. Обратите внимание, в списке `namePrefix` лишь один префикс. Вот что будет, если префиксов два:

```haskell
main =
    print [prefix ++ name | name <- names, prefix <- namePrefix]
    where names = ["James", "Victor", "Denis", "Michael"]
          namePrefix = ["Mr. ", "sir "] -- Теперь префиксов два
```

В этом случае на выходе будет:

```bash
["Mr. James","sir James","Mr. Victor","sir Victor","Mr. Denis","sir Denis","Mr. Michael","sir Michael"]
```

В этом случае мы последовательно использовали _каждый_ элемент из списка `names` и _каждый_ элемент из списка `namePrefix`.

## Добавляем условие

Предикат не всегда применим к элементам списка. В ряде случаев нам нужно условие. Добавим его:

```haskell
main =
    print [if car == "Bentley" then "Wow!" else "Good!" | car <- cars]
    where cars = ["Mercedes",
                  "BMW",
                  "Bentley",
                  "Audi",
                  "Bentley"]
```

Результат:

```bash
["Good!","Good!","Wow!","Good!","Wow!"]
```

Мы прошлись по списку марок автомобилей и применили к каждой из них условие, которое вернуло строку `"Wow!"` или строку `"Good!"`.

## Добавляем локальное выражение

Мы можем добавить сюда и локальное выражение с помощью уже известного нам `let`. Например так:

```haskell
import Data.Char

main = print [toUpper c | c <- "http",
                          let hletter = 'h' in c /= hletter]
```

Промежуточное значение может быть использовано во избежание дубляжа при наличии нескольких предикатов.

## Пример

Разберём более практичный пример:

```haskell
import Data.List

checkGooglerBy :: String -> String
checkGooglerBy email =
    if "gmail.com" `isSuffixOf` email
    then nameFrom email ++ " is a Googler!"
    else email
    where nameFrom fullEmail = takeWhile (/= '@') fullEmail

main = print [checkGooglerBy email | email <- ["adam@gmail.com",
                                               "bob@yahoo.com",
                                               "richard@gmail.com",
                                               "elena@yandex.ru",
                                               "denis@gmail.com"]]
```

Результат:

```haskell
["adam is a Googler!","bob@yahoo.com","richard is a Googler!","elena@yandex.ru","denis is a Googler!"]
```

Мы проанализировали список email-адресов, и заменили все gmail-адреса фразой, начинающейся с имени пользователя.

Рассмотрим эту строку:

```haskell
takeWhile (/= '@') fullEmail
```

Скелет стандартной функции `takeWhile` можно отобразить так:

```
takeWhile PREDICATE LIST
```

Здесь мы говорим: "Последовательно забирай (take) элементы из списка `LIST` до тех пор (While), пока `PREDICATE`, применённый к этим элементам, возвращает `True`. Если наткнёшься на элемент, не соответствующий этому предикату, немедленно прекращай работу и возвращай список из ранее полученных элементов". Нам нужно извлечь имя пользователя из его email-адреса, а значит, мы бежим по email до тех пор, пока символы не равны `'@'`, что и отражается предикатом `(/= '@')`. Как только натыкаемся на собачку - возвращаем всё, находящееся перед ней.

## В сухом остатке

1. Генератор списка - это конструкция, порождающая новый список из одного или нескольких имеющихся списов.
2. Новый список порождается в результате применения различных функций к элементам имеющегося списка/списков.






----
title: Диапазоны
prevChapter: /ru/about-lists/lists-at-a-glance.html
nextChapter: /ru/about-lists/tuples.html
----

Диапазон - это конструкция, автоматически создающая список по заданному признаку.

## Суть

Если нам нужно создать список целых чисел от 1 до 10, мы можем написать так:

```haskell
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

а можем просто задать диапазон:

```haskell
[1..10]
```

Готово. Разумеется, такой фокус можно проделать не только с числами. Например, вот так мы получим список всех букв английского алфавита в нижнем регистре:

```haskell
main = print ['a'..'z']
```

На выходе получим красивый список символов (то есть обыкновенную строку):

```bash
"abcdefghijklmnopqrstuvwxyz"
```

## Умные диапазоны

Диапазоны можно задавать весьма гибко. Например, так мы можем получить список всех чётных чисел от 2 до 30:

```haskell
main = print [2,4..30]
```

Мы задали шаг между значениями элементов, а остальные значения были созданы уже автоматически.

Конечно, этот фокус работает не только с целыми числами, мы вполне можем написать и так:

```haskell
main = print [1.1, 1.2..2.9]
```

В результате получим список чисел с шагом в 0.1.

Можно, кстати, и в порядке убывания:

```haskell
main = print [120,110..10]
```

На выходе получим список с десятками:

```bash
[120,110,100,90,80,70,60,50,40,30,20,10]
```

А вот чего компилятор не потерпит, так это излишних указаний с вашей стороны. Поэтому не пишите так:

```haskell
main = print [2,4,6..30]
```

и так тоже не пишите:

```haskell
main = print [2,4..28,30]
```

Такого рода уточнения компилятору не нужны.

## Без конца

Как вы помните, ленивость языка Haskell позволяет нам оперировать бесконечными списками. И мы можем создать такой список через диапазон.

Например, вот такой диапазон:

```haskell
[1..]
```

создаст бесконечный список целых чисел, начиная с 1. Но, как вы уже знаете, в действительности созданный этим диапазоном список будет вовсе не бесконечным, а лишь _достаточно_ большим:

```haskell
main = print $ take 5 [1..]
```

Вывод:

```bash
[1,2,3,4,5]
```

Мы можем задать и шаг:

```haskell
main = print $ take 5 [2,4..]
```

В этом случае вывод будет таким:

```bash
[2,4,6,8,10]
```

## В сухом остатке

1. Диапазон служит для автоматического создания списка по заданным критериям.
2. Учитывая ленивую природу Haskell, мы можем оперировать диапазонами, создающими бесконечные списки.


