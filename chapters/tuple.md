# Кортеж

В этой главе мы познакомимся с кортежем и ещё ближе подружимся с паттерн матчингом.

Кортеж (англ. tuple) &mdash; ещё одна стандартная структура данных, с которой нам следует познакомиться. В отличие от списка, кортеж может содержать данные как одного типа, так и разных.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Структуры, способные содержать данные разных типов, называют ещё гетерогенными (в переводе с греческого: &laquo;разного рода&raquo;).
</span></div>

Вот как он выглядит:

```haskell
("Haskell", 2010)
```

Круглые скоби, в отличие от списка. Этот кортеж содержит два элемента типа `String` и `Int` соответственно. Можно написать и так:

```haskell
("Haskell", "2010", "Standard")
```

То есть ничто не мешает нам хранить в кортеже данные одного типа.

## Тип кортежа

Тип списка строк, как вы помните, `[String]`. И не важно, сколько строк мы запихнули в список &mdash; его тип останется неизменным. С кортежем же дело обстоит абсолютно иначе.

Тип кортежа зависит от количества его элементов. Вот тип кортежа, содержащего две строки:

```haskell
(String, String)
```

Вот ещё пример:

```haskell
(Double, Double, Int)
```

И ещё:

```haskell
(Bool, Double, Int, String)
```

То есть тип кортежа явно отражает его содержимое. Поэтому если функция применяется к кортежу из двух строк, применить её к кортежу из трёх не получится, потому что типы таких кортежей различаются:

```haskell
-- Несовместимые типы
(String, String)
(String, String, String)
```

## Действия над кортежами

В отличие от списка, в отношении которого можно сделать великое множество действий, с кортежем обычно делают только одно &mdash; извлекают хранящиеся в нём данные. Например:

```haskell
makeAlias :: String -> String -> (String, String)
makeAlias host alias = (host, alias)
```

Пожалуй, ничего проще придумать нельзя: на входе два аргумента, на выходе &mdash; двуэлементный кортеж с этими аргументами.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Двуэлементный кортеж называют ещё парой (англ. pair). И хотя кортеж может содержать сколько угодно элементов, на практике чаще всего встречаются именно пары.
</span></div>

Обратите внимание, насколько легко создаётся кортеж. Причина тому &mdash; уже знакомый нам паттерн матчинг:

```haskell
makeAlias host alias = (host,    alias)

          это           к этому

               а это             к тому
```

Мы просто пишем прямое соответствие между левой и правой сторонами определения. Ничего удобнее и проще и придумать нельзя. И если бы мы хотели получить кортеж из трёх элементов с дубляжом хоста (ну вдруг), это выглядело бы так:

```haskell
makeAlias :: String -> String -> (String, String, String)
makeAlias host alias = (host,    host,      alias)
          это           к этому  и к этому

               а вот                        к тому
               это
```

Таким же образом, через паттерн матчинг, мы извлекаем элементы из кортежа. Например:

```haskell
main :: IO ()
main =
  let (host, alias) = makeAlias "173.194.71.106" "www.google.com"
  in print (host ++ ", " ++ alias)
```

Функция `makeAlias` даёт нам пару из хоста и имени. Но что это за странная запись возле уже знакомого нам слова `let`? Это промежуточное выражение, но выражение хитрое, образованное через паттерн матчинг. Чтобы было понятнее, сначала перепишем функцию без него:

```haskell
main :: IO ()
main =
  let pair  = makeAlias "173.194.71.106" "www.google.com"
      host  = fst pair
      alias = snd pair
  in print (host ++ ", " ++ alias)
```

При запуске этой программы мы получим:

```bash
"173.194.71.106, www.google.com"
```

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Оператор `++` соединяет две строки в одну. Строго говоря, он соединяет два списки в один, но мы-то уже знаем, что `String` есть ни что иное, как `[Char]`. Таким образом, `"google" ++ ".com" = "google.com"`
</span></div>

Стандратные функции `fst` и `snd` возвращают первый и второй элемент кортежа соответственно. Выражение `pair` соответствует паре, выражение `host` &mdash; значению хоста, а `alias` &mdash; значению имени. Но не кажется ли вам такой способ несколько избыточным? Мы в Haskell любим изящные решения, поэтому предпочитаем паттерн матчинг. Вот как получается вышеприведённый способ:

```haskell
let (host, alias) = makeAlias "173.194.71.106" "www.google.com"
let (host, alias) = ("173.194.71.106", "www.google.com")
                     данное значение
     это
     хост
                                       а вот это значение
           это
           имя
```

Вот такая простая магия. Функция `makeAlias` даём там пару, и мы достоверно знаем это! А если знаем, нам не нужно вводить промежуточные выражения вроде `pair`. Мы сразу говорим:

```haskell
let (host, alias) = makeAlias "173.194.71.106" "www.google.com"
                    то, что ты в конечном итоге вычислишь
     это вот
     такая пара
```

Это &laquo;зеркальная&raquo; модель: через паттерн матчинг формируем:

```haskell
-- Формируем правую сторону
-- на основе левой...
host alias = (host, alias)
____          ____
     _____          _____
```

и через него же извлекаем:

```haskell
-- Формируем левую сторону
-- на основе правой...
(host, alias) = ("173.194.71.106", "www.google.com")
 ____            ________________
       _____                       ________________
```

Вот ещё один пример работы с кортежем через паттерн матчинг:

```haskell
chessMove :: String -> (String, String) -> (String, (String, String))
chessMove color (from, to) = (color, (from, to))

main :: IO ()
main = print (color ++ ": " ++ from ++ "-" ++ to)
  where
    (color, (from, to)) = chessMove "white" ("e2", "e4")
```

И на выходе получаем:

```bash
"white: e2-e4"
```

Функция `chessMove` даёт нам кортеж с кортежем, а раз мы точно это знаем, сразу указываем `where`-выражение в виде образца:

```haskell
(color, (from, to)) = chessMove "white" ("e2", "e4")
 _____                          _______
         ____                            ____
               __                              ____

```

## Не всё

Мы можем вытаскивать по образцу лишь часть нужной нам информации. Помните универсальный образец `_`? Вот пример:

```haskell

```

## А если ошиблись?

При использовании паттерн матчинга в отношении пары следует быть внимательным. Раз уж используем образец.




