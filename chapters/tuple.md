# Кортеж

В этой главе мы познакомимся с кортежем и ещё ближе подружимся с паттерн матчингом.

Кортеж (англ. tuple) &mdash; ещё одна стандартная структура данных, с которой нам следует познакомиться. В отличие от списка, кортеж может содержать данные как одного типа, так и разных.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Структуры, способные содержать данные разных типов, называют ещё гетерогенными (в переводе с греческого: &laquo;разного рода&raquo;).
</span></div>

Вот как он выглядит:

```haskell
("Haskell", 2010)
```

Круглые скоби, в отличие от списка. Этот кортеж содержит два элемента типа `String` и `Int` соответственно. Можно написать и так:

```haskell
("Haskell", "2010", "Standard")
```

То есть ничто не мешает нам хранить в кортеже данные одного типа.

## Тип кортежа

Тип списка строк, как вы помните, `[String]`. И не важно, сколько строк мы запихнули в список &mdash; его тип останется неизменным. С кортежем же дело обстоит абсолютно иначе.

Тип кортежа зависит от количества его элементов. Вот тип кортежа, содержащего две строки:

```haskell
(String, String)
```

Вот ещё пример:

```haskell
(Double, Double, Int)
```

И ещё:

```haskell
(Bool, Double, Int, String)
```

То есть тип кортежа явно отражает его содержимое. Поэтому если функция применяется к кортежу из двух строк, применить её к кортежу из трёх не получится, потому что типы таких кортежей различаются:

```haskell
-- Несовместимые типы
(String, String)
(String, String, String)
```

## Действия над кортежами

Со списками можно делать много всего, а вот с кортежами &mdash; не очень. Самое частое действие в отношении уже созданного кортежа &mdash; извлечение хранящихся в нём данных. Например:

```haskell
makeAlias :: String -> String -> (String, String)
makeAlias host alias = (host, alias)
```

Пожалуй, ничего проще придумать нельзя: на входе два аргумента, на выходе &mdash; двуэлементный кортеж с этими аргументами.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Двуэлементный кортеж называют ещё парой (англ. pair). И хотя кортеж может содержать сколько угодно элементов, на практике пары встречаются чаще всего.
</span></div>

Обратите внимание, насколько легко создаётся кортеж. Причина тому &mdash; уже знакомый нам паттерн матчинг:

```haskell
makeAlias host alias = (host,    alias)

          это           к этому

               а это             к тому
```

Мы просто пишем прямое соответствие между левой и правой сторонами определения. Ничего удобнее и проще и придумать нельзя. И если бы мы хотели получить кортеж из трёх элементов с дубляжом хоста (ну вдруг), это выглядело бы так:

```haskell
makeAlias :: String -> String -> (String, String, String)
makeAlias host alias = (host,    host,      alias)

          это           к этому  и к этому

               а вот                        к тому
               это
```

Таким же образом, через паттерн матчинг, мы извлекаем элементы из кортежа. Например:

```haskell
main :: IO ()
main =
  let (host, alias) = makeAlias "173.194.71.106"
                                "www.google.com"
  in print (host ++ ", " ++ alias)
```

Функция `makeAlias` даёт нам пару из хоста и имени. Но что это за странная запись возле уже знакомого нам слова `let`? Это промежуточное выражение, но выражение хитрое, образованное через паттерн матчинг. Чтобы было понятнее, сначала перепишем функцию без него:

```haskell
main :: IO ()
main =
  let pair  = makeAlias "173.194.71.106"
                        "www.google.com"
      host  = fst pair
      alias = snd pair
  in print (host ++ ", " ++ alias)
```

При запуске этой программы мы получим:

```bash
"173.194.71.106, www.google.com"
```

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Оператор `++` &mdash; это оператор конкатенации, склеивающий две строки в одну. Строго говоря, он склеивает два списка, но мы-то уже знаем, что `String` есть ни что иное, как `[Char]`. Таким образом, `"google" ++ ".com"` даёт `"google.com"`.
</span></div>

Стандратные функции `fst` и `snd` возвращают первый и второй элемент кортежа соответственно. Выражение `pair` соответствует паре, выражение `host` &mdash; значению хоста, а `alias` &mdash; значению имени. Но не кажется ли вам такой способ несколько избыточным? Мы в Haskell любим изящные решения, поэтому предпочитаем паттерн матчинг. Вот как получается вышеприведённый способ:

```haskell
let (host, alias) = makeAlias "173.194.71.106" "www.google.com"
let (host, alias) = ("173.194.71.106", "www.google.com")
                     данное значение
     это
     хост
                                       а вот это значение
           это
           имя
```

Вот такая простая магия. Функция `makeAlias` даём там пару, и мы достоверно знаем это! А если знаем, нам не нужно вводить промежуточные выражения вроде `pair`. Мы сразу говорим:

```haskell
let (host, alias) = makeAlias "173.194.71.106" "www.google.com"
                    то, что ты в конечном итоге вычислишь
     это вот
     такая пара
```

Это &laquo;зеркальная&raquo; модель: через паттерн матчинг формируем:

```haskell
-- Формируем правую сторону
-- на основе левой...
host alias = (host, alias)
____          ____
     _____          _____
```

и через него же извлекаем:

```haskell
-- Формируем левую сторону
-- на основе правой...
(host, alias) = ("173.194.71.106", "www.google.com")
 ____            ________________
       _____                       ________________
```

Вот ещё один пример работы с кортежем через паттерн матчинг:

```haskell
chessMove :: String -> (String, String) -> (String, (String, String))
chessMove color (from, to) = (color, (from, to))

main :: IO ()
main = print (color ++ ": " ++ from ++ "-" ++ to)
  where
    (color, (from, to)) = chessMove "white" ("e2", "e4")
```

И на выходе получаем:

```bash
"white: e2-e4"
```

Функция `chessMove` даёт нам кортеж с кортежем, а раз мы точно знаем вид ожидаемого кортежа, то сразу указываем `where`-выражение в виде образца:

```haskell
(color, (from, to)) = chessMove "white" ("e2", "e4")
 _____                          _______
         ____                            ____
               __                              ____

```

Кстати, я об этом не упомянул, но теоретически кортеж может состоять из одного-единственного элемента:

```haskell
useless :: String -> (String)
useless s = (s)

main :: IO ()
main = putStrLn s
  where (s) = useless "some"
```

Хотя, учитывая гетерогенность кортежа, мне трудно представить ситуацию, в которой одноэлементный кортеж был бы реально полезен.

## Не всё

Мы можем вытаскивать по образцу лишь часть нужной нам информации. Помните универсальный образец `_`? Взгляните:

```haskell
-- Поясняющие псевдонимы
type UUID     = String
type FullName = String
type Email    = String
type Age      = Int
type Patient = (UUID, FullName, Email, Age)

patientEmail :: Patient -> Email
patientEmail (_, _, email, _) = email

main :: IO ()
main =
  putStrLn (patientEmail ( "63ab89d"
                         , "John Smith"
                         , "johnsm@gmail.com"
                         , 59
                         ))
```

Функция `patientEmail` даёт нам почту пациента. Тип `Patient` &mdash; это псевдоним для кортежа из четырёх элементов: уникальный идентификатор, полное имя, адрес почты и возраст. Дополнительные псевдонимы делают наш код яснее: одно дело видеть безликую `String` и совсем другое &mdash; вполне понятный `Email`.

Рассмотрим внутренность функции `patientEmail`:

```haskell
patientEmail (_, _, email, _) = email
```

Функция говорит нам: &laquo;Да, я знаю, что мой аргумент &mdash; это четырёхэлементный кортеж, но меня в нём интересует исключительно третий по счёту элемент, соответствующий адресу почты, его я и верну&raquo;. Универсальный образец `_` делает наш код лаконичнее и понятнее, ведь он помогает нам игнорировать то, что нам неинтересно. Строго говоря, мы не обязаны использовать `_`, но с ним будет куда лучше.

## А если ошиблись?

При использовании паттерн матчинга в отношении пары следует быть внимательным. Представим себе, что вышеупомянутый тип `Patient` был расширен:

```haskell
type UUID      = String
type FullName  = String
type Email     = String
type Age       = Int
type DiseaseId = Int
type Patient = (UUID, FullName, Email, Age, DiseaseId)
```

Был добавлен идентификатор заболевания. И всё бы хорошо, но внести изменения в функцию `patientEmail` мы забыли:

```haskell
-- А где пятый элемент?
patientEmail :: Patient -> Email
patientEmail (_, _, email, _) = email
```

К счастью, в этом случае компилятор строго обратит наше внимание на ошибку:

```bash
    Couldn't match type ‘(t0, t1, String, t2)’
                   with ‘(UUID, FullName, Email, Age, DiseaseId)’
    Expected type: Patient
      Actual type: (t0, t1, String, t2)
    In the pattern: (_, _, email, _)
```

Оно и понятно: функция `patientEmail` использует образец, который уже невалиден. Вот почему при использовани паттерн матчинга следует быть внимательным.

На этом наше знакомство с кортежем считаю завершённым. Далее мы будем использовать их периодически, а в одной из следующих глав мы узнаем ещё об одном действии в отношении кортежа.

