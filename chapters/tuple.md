----
title: Кортежи
prevChapter: /ru/ranges.html
nextChapter: /ru/list-comprehension.html
----

Кортеж (англ. tuple) - очень простая структура данных. Он тоже хранит в себе набор элементов, однако к списку не имеет никакого отношения. Главная особенность - гетерогенность: кортеж способен хранить в себе элементы разных типов.

Вот как он выглядит:

```haskell
("Denis", "Shevchenko")  -- Кортеж из двух строк.
```

Гетерогенность позволяет нам написать и так:

```haskell
("Denis", 1.234, 'a')  -- Три элемента - три типа.
```

Кстати, из гетерогенность кортежа вытекает важная особенность его типа. Например, если у нас есть два списка, различных по размеру:

```haskell
["Denis", "Vasil`evich", "Shevchenko"]
["Denis", "Shevchenko"]
```

тип обоих этих списков одинаков, а именно `[String]`. Тип списка не зависит от количества элементов в нём.

С кортежами всё обстоит совершенно иначе. Если у нас есть два кортежа, различных по длине:

```haskell
("Denis", "Vasil`evich", "Shevchenko")
("Denis", "Shevchenko")
```

типы этих кортежей абсолютно разные: тип первого - `(String, String, String)`, а тип второго - `(String, String)`. Тип кортежа неразрывно связан с его размером. Поэтому если функцию, в качестве аргумента ожидающую кортеж из двух строк, применить к кортежу из трёх строк, компилятор выразит свой категорический протест:

```bash
Could not match expected type `(String, String)`
             with actual type `([Char], [Char], [Char])`
```

Оно и понятно: ожидали кортеж из двух строк, а тут вдруг - из трёх!

Кортеж может быть и пустым, то есть не содержать в себе ни одного элемента:

```haskell
()
```

## Что с ним можно делать

Единственное, что можно сделать с кортежем - извлечь хранящиеся в нём элементы. Всё. И сразу пример.

Одним из наиболее распространённых случаев использования кортежа в реальном коде считается возврат из функции нескольких значений разного типа. Вот так:

```haskell
endpoint :: (String, Int)
endpoint = ("127.0.0.1", 8080)
```

Итак, вот наша константа (или, если угодно, константная функция), возвращающая двухэлементный кортеж (обычно называемый парой) с IP-адресом и портом. Теперь воспользуемся этими значениями:

```haskell
main :: IO ()
main = do
    let (host, port) = endpoint
    print $ host ++ ":" ++ show port
```

Здесь, используя уже знакомый нам паттерн матчинг, мы вытащили оба элемента из кортежа:

```haskell
    let (host, port) = endpoint
```

Поскольку мы точно знаем, что перед нами пара, первым элементом которой является хост, а вторым - порт, мы смогли явно указать это в левом образце. Как вы понимаете, мы не обязаны вытаскивать оба значения, можно обойтись и одним:

```haskell
    let (_, port) = endpoint
```

Существуют также две стандартные функции `fst` и `snd`, предназначенные для извлечения первого и второго элементов пары соответственно. С ними наш пример изменится:

```haskell
main :: IO ()
main = do
    let host = fst endpoint
        port = snd endpoint
    print $ host ++ ":" ++ show port
```

Получилось длиннее. Можно, конечно, и короче:

```haskell
main :: IO ()
main = do
    print $ fst endpoint ++ ":" ++ show (snd endpoint)
```

Код уменьшился, но стал хуже: из него теперь не ясно, что является первым элементом пары, а что - вторым. Да и вообще, на практике функциями `fst` и `snd` пользуются весьма редко, потому что, как вы могли убедиться, паттерн матчинг проще. Более того, сами функции `fst` и `snd` реализованы через паттерн матчинг, взгляните на их определение:

```haskell
fst :: (a, b) -> a
fst (x, _) = x      -- Второй элемент игнорируем...

snd :: (a, b) -> b
snd (_, y) = y      -- Первый элемент игнорируем...
```

И как вы уже догадались, увеличение числа элементов кортежа никак не меняет принцип работы с ним. Вот пример функции, отображающей выборочную информацию о пользователе: 

```haskell
type FirstName = String
type LastName  = String
type Email     = String
type BirthYear = Int
type UserInfo = (FirstName, LastName, Email, BirthYear)

showUserEmail = UserInfo -> String
showUserEmail (_, _, email, _) = "User's email is '" ++ email ++ "'"
```

Здесь мы определили тип-псевдоним для четырёхэлементного кортежа, содержащего соответственно имя, фамилию, почту и год рождения пользователя. Далее, в функции `showUserEmail` мы использовали паттерн матчинг, потому что точно знаем, что аргументом является четырёхэлементный кортеж. А поскольку здесь нас интересует лишь почта, идущая третьей по счёту, мы явно отображаем это в левом образце, игнорируя прочие три значения.

Строго говоря, существуют готовые пакеты для извлечения элементов из многоэлементных кортежей без явного паттерн матчинга. Например, пакет [tuple](http://hackage.haskell.org/package/tuple). Установив его, мы сможем переписать пример с почтой так:

```haskell
import Data.Tuple.Select

...

showUserEmail = UserInfo -> String
showUserEmail userInfo = "User's email is '" ++ sel3 userInfo ++ "'"
```

Функция `sel3`, как следует из её названия, выбирает третий по счёту элемент кортежа.

С одной стороны, подобный пакет полезен, ведь если бы у нас был кортеж, скажем, из десяти элементов, то явный образец получился бы достаточно длинным (и неудобным в использовании). С другой стороны, в реальных Haskell-проектах многоэлементные кортежи встречаются крайне редко, поэтому явный паттерн матчинг в 99% случаев является наилучшим решением.

## В сухом остатке

1. Кортеж - это структура данных, позволяющая хранить значения разных типов.
2. Тип кортежа определяется количеством и типом хранящихся в нём значений.
3. Единственное, что мы можем сделать с кортежем - извлечь из него значения, если таковые имеются.
