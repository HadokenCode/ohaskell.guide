# Лямбда-функция

Пришло время познакомиться с важной концепцией &mdash; лямбда-функцией. Именно с неё всё и началось. Приготовьтесь: в этой главе нас ждут новые открытия.

## Истоки

В далёких 1930-х молодой американский математик [Алонзо Чёрч](https://ru.wikipedia.org/wiki/%D0%A7%D1%91%D1%80%D1%87,_%D0%90%D0%BB%D0%BE%D0%BD%D0%B7%D0%BE) задался вопросом о том, что значит &laquo;вычислить&raquo; что-то. Плодом его размышлений явилась система для формализации понятия &laquo;вычисление&raquo;, и назвал он её &laquo;лямбда-исчислением&raquo; (англ. lambda calculus, по имени греческой буквы `λ`).

В основе этой системы лежит лямбда-функция, которую можно считать &laquo;матерью функционального программирования&raquo; в целом и Haskell в частности. Далее буду называть её ЛФ.

В отношении ЛФ можно смело сказать: &laquo;Всё гениальное просто&raquo;. Идея ЛФ столь полезна именно потому, что она предельно проста. ЛФ &mdash; это анонимная функция. Вот как она выглядит в Haskell:

```haskell
\x -> x * x
```

Обратный слэш в начале &mdash; признак ЛФ. Сравните с математической формой записи:

```haskell
λx . x * x
```

Похоже, не правда ли? Воспринимайте обратный слэш в определении ЛФ как спинку буквы `λ`.

ЛФ представляет собой простейший вид функции, эдакая функция, раздетая догола. У неё забрали не только объявление, но и имя, оставив лишь необходимый минимум в виде имён аргументов и внутреннего выражения. Алонзо Чёрч понял: чтобы применить функцию, вовсе необязательно её именовать. И если у обычной функции сначала идёт объявление/определение, а затем (где-то) применение с использованием имени, то у ЛФ всё куда проще: мы её определяем и тут же применяем, на месте. Вот так:

```haskell
(\x -> x * x) 5
```

Помните функцию `square`? Вот это её лямбда-аналог:

```haskell
(\x -> x * x)     5

лямбда-выражение  аргумент
```

Лямбда-выражение порождает временную функцию, которую мы сразу же применяем к аргументу `5`.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
ЛФ с одним аргументом ещё называют &laquo;ЛФ от одного аргумента&raquo; или &laquo;ЛФ одного аргумента&raquo;.
</span></div>

## Строение

Строение ЛФ предельно простое:

```haskell
\        x          ->  x * x
признак  имя            выражение
ЛФ       аргумента
```

Соответственно, если ЛФ применяется к двум аргументам &mdash; пишем так:

```haskell
\        x          y          ->  x * y
признак  имя 1      имя 2          выражение
ЛФ       аргумента  аргумента
```

И когда мы применяем такую функцию:

```haskell
(\x y -> x * y) 10 4
```

то просто подставляем `10` на место `x`, а `4` &mdash; на место `y`, и получаем выражение `10 * 4`:

```haskell
(\x y -> x * y) 10 4 = 10 * 4 = 40
```

В общем, всё как с обычной функцией, даже проще.

Мы можем ввести промежуточное значение для ЛФ:

```haskell
main :: IO ()
main = print (mul 10 4)
  where mul = \x y -> x * y
```

Здесь выражение `mul` объявляется равным ЛФ, и теперь мы применяем `mul` так же, как если бы это было само лямбда-выражение:

```haskell
mul 10 4 = (\x y -> x * y) 10 4 = 10 * 4
```

И здесь мы приблизились к одному важному открытию.

## Тип функции

Мы знаем, что у всех данных в Haskell-программе обязательно есть какой-то тип, проверяемый на этапе компиляции. Вопрос: какой тип у `mul` из предыдущего примера?

```haskell
where mul = \x y -> x * y  -- Тип?
```

Ответ прост: тип `mul` такой же, как и у этой ЛФ. Из этого мы делаем важный вывод: ЛФ имеет тип, как и обычные данные. Но если ЛФ тоже является функцией (просто предельно лаконичной) &mdash; значит и у обыкновенной функции тоже есть тип!

В императивных языках между функциями и данными проведена чёткая граница: вот это функции, а вон то &mdash; данные. Однако в Haskell между данными и функциями разницы нет, ведь и то и другое порождается неким выражением. И вот каков тип функции `mul`:

```haskell
mul :: a -> a -> a
```

Погодите, скажете вы, но ведь это же объявление функции! Совершенно верно: объявление функции &mdash; это и есть указание её типа. Помните, когда мы впервые познакомились с функцией, я уточнил, что её объявление разделено двойным двоеточием? Так вот это двойное двоеточие и представляет собой указание типа:

```haskell
mul  ::     a -> a -> a

вот  имеет  |вот такой|
это  тип
```

Точно так же мы можем указать тип любых других данных:

```haskell
let coeff = 12 :: Double
```

Хотя мы знаем, что в Haskell типы выводятся автоматически, иногда мы хотим взять эту заботу на себя. В данном случае мы явно говорим: &laquo;Пусть выражение `coeff` будет равно `12`, но тип пусть имеет `Double`, а не `Int`&raquo;. Так же и с функцией: когда мы объявляем её &mdash; мы тем самым указываем её тип.

Но вы спросите, можем ли мы не указывать тип функции явно? Можем:

```haskell
square x = x * x
```

Это наша старая знакомая, функция `square`. Когда она будет применена к значению типа `Int`, тип аргумента будет выведен автоматически как `Int`.

И раз функция характеризуется типом как и все другие данные, мы делаем ещё одно важное открытие: функциями можно оперировать как данными. И запомните эту важную и простую мысль!

Например, можно создать список функций:

```haskell
main :: IO ()
main = putStrLn ((head functions) "Hi")
  where
    functions = [ \x -> x ++ " val1"
                , \x -> x ++ " val2"
                ]
```

Выражение `functions` &mdash; это список из двух функций. Два лямбда-выражения порождают эти две функции, но до момента применения они ничего не делают, они безжизненны и бесполезны. Но когда мы применяем функцию `head` к этому списку, мы получаем первый элемент списка, то есть первую функцию. И получив, тут же применяем эту функцию к строке `"Hi"`:

```haskell
putStrLn ((head functions)  "Hi")

          |    первая    |  её
          |    функция   |  аргумент
          |   из списка  |
```

Это равносильно коду:

```haskell
putStrLn ((\x -> x ++ " val1") "Hi")
```

Поэтому при запуске программы мы получим:

```bash
Hi val1
```

Кстати, а каков тип списка `functions`? Его тип, в данном случае тип `[String -> String]`. То есть список функций с одним аргументом типа `String`, возвращающих значение типа `String`.

## Локальные функции

Раз уж между ЛФ и простыми функциями фактически нет различий, а функции есть частный случай данных, мы можем создавать функции локально для других функций:

```haskell
import Data.List

validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign e = "@" `isInfixOf` e
    endsWithCom e = ".com" `isSuffixOf` e

main :: IO ()
main = putStrLn (if validComEmail my
                   then "It's ok!"
                   else "Non-com email!")
  where
    my = "haskeller@gmail.com"
```

Несколько наивная функция `validComEmail` проверяет `.com`-почтовый адрес. Её выражение образовано оператором `&&` и двумя выражениями типа `Bool`. Вот как образованы эти выражения:

```haskell
containsAtSign e = "@" `isInfixOf` e
endsWithCom e = ".com" `isSuffixOf` e
```

Это &mdash; две функции, которые мы определили прямо в `where`-секции, поэтому они существуют только для основного выражения функции `validComEmail`. С простыми функциями так поступают очень часто: где она нужна, там и определена. Мы могли бы написать и более явно:

```haskell
validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign :: String -> Bool
    containsAtSign e = "@" `isInfixOf` e

    endsWithCom :: String -> Bool
    endsWithCom e = ".com" `isSuffixOf` e
```

Вот, теперь уже сомнений не возникает. Указывать тип примитивных функций, как правило, необязательно.

А вот как этот код выглядит с ЛФ:

```haskell
validComEmail :: String -> Bool
validComEmail email =
    containsAtSign email && endsWithCom email
  where
    containsAtSign = \e -> "@" `isInfixOf` e
    endsWithCom = \e -> ".com" `isSuffixOf` e
```

Теперь выражения `containsAtSign` и `endsWithCom` приравнены ЛФ от одного аргумента. В этом случае мы конечно же не указываем тип этих выражений. Впрочем, если очень хочется, можете и указать:

```haskell
containsAtSign = (\e -> "@" `isInfixOf` e) :: String -> Bool
endsWithCom = (\e -> ".com" `isSuffixOf` e) :: String -> Bool
```

Лямбда-выражение взято в скобки, чтобы указание типа относилось к выражени в целом, а не только к аргументу `e`. Впрочем, на практике указание типа ЛФ встречается нечасто, ибо незачем.

Вот мы и познакомились с &laquo;матерью Haskell&raquo;. Теперь мы будем использовать ЛФ периодически.

И напоследок, вопрос. Помните тип функции `mul` в начале главы?

```haskell
mul :: a -> a -> a
```

Что это за буква `a`? Во-первых, мы не встречали такой тип ранее, а во-вторых, разве имя типа в Haskell не должно начинаться с большой буквы? Должно. А всё дело в том, что буква `a` в данном случае &mdash; это не имя типа. А вот что это такое, мы узнаем в одной из ближайших глав.

