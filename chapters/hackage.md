# Hackage и библиотеки

Hackage &mdash; это главный репозиторий Haskell-библиотек, или, как принято у нас называть, пакетов (англ. package). Название репозитория происходит от слияния слов `Haskell` и `package`.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Hackage существует с 2008 года, и с тех пор увеличился с нескольких десятков пакетов до почти 9 тысяч.
</span></div>

По сути, пакет представляет собой совокупность модулей. Существуют большие пакеты, состоящие из многих десятков модулей, но есть и такие, в которых модуль всего один.

Чтобы воспользоваться пакетом, необходимо сделать три шага:

1. найти этот пакет,
2. включить его в наш проект,
3. импортировать из него нужные нам модули.

## Ищем

Искать пакет можно двумя способами: на единой Hackage-странице или через специальный поисковик.

Все пакеты, живущий в Hackage, можно увидеть на [одной странице](http://hackage.haskell.org/packages/). Это весьма удобно: браузерный поиск поможет вам искать пакеты по всем доступным тематическим категориям.

А ещё есть особые поисковики по Hackage. Названы они в честь поисковых гигантов:

1. [Hoogle](http://www.haskell.org/hoogle/)
2. [Hayoo!](http://holumbus.fh-wedel.de/hayoo/hayoo.html)

Эти поисковики скрупулёзно осматривают внутренности Hackage, и мы будем очень часто ими пользоваться. Сейчас, в качестве примера, возьмём пакет `text`, предназначенный для работы с текстом. Этот пакет, кстати, очень нам пригодится, живёт он [тут](http://hackage.haskell.org/package/text).

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Каждый из Hackage-пакетов живёт по адресу, сформированному по неизменной схеме: `http://hackage.haskell.org/package/ИМЯПАКЕТА`.
</span></div>

## Включаем

Открываем сборочный файл проекта `real.cabal`, находим секцию `executable real-exe` и в поле `build-depends` через запятую дописываем имя пакета:

```haskell
  build-depends:       base
                     , real
                     , text
```

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Файл с расширением `.cabal` &mdash; это обязательный сборочный файл нашего проекта. Он содержит главные инструкции, касающиеся сборки проекта. С синтаксисом сборочного файла мы будем постепенно знакомиться в следующих главах.
</span></div>

Теперь выполняем:

```bash
$ stack install
```

Начнётся повторная сборка проекта, но перед нею `stack`, увидев новую зависимость, сделает то что нам и нужно: установит сам пакет `text` и все те пакеты, от которых он в свою очередь зависит.

Готово. Отныне мы можем импортировать нужные нам модули из пакета `text`. В следующих главах мы сделаем это неоднократно.

## Прелюдия

Существует один стандартный модуль, который по умолчанию автоматически импортируется во все наши модули. Имя ему &mdash; [Prelude](http://hackage.haskell.org/package/base/docs/Prelude.html). В этому модуле содержатся самые базовые Haskell-инструменты, многие из которых мы будем использовать постоянно.

















----
title: О модулях
prevChapter: /ru/miscellaneous/index.html
nextChapter: /ru/miscellaneous/pattern-matching.html
----

Как вы помните, в самом начале мы уже немного говорили о модулях. Пришло время изучить их более основательно.

## Об иерархии

Зайдём в каталог `src`, создадим в нём подкаталог `Utils` и разместим в нём файл `Helpers.hs`. Откроем и напишем следующее:
 
```haskell
module Utils.Helpers (
    calibrate,
    graduate
) where

coefficient :: Double
coefficient = 0.99874

calibrate length = length * coefficient

graduate length = length / coefficient
```

Имя модуля не просто `Helpers`, а `Utils.Helpers`, то есть оно теперь отражает иерархию наших исходников. И хотя мы можем и не делать этого, но общая практика в мире Haskell именно такова: указывать имя модуля с полным путём к нему от корня проекта. Именно поэтому все модули, которые мы уже использовали, именовались полным путём, например:

```haskell
import Data.String.Utils
```

Теперь вы знаете, что подобное длинное название - это всего лишь путь: в исходниках данного пакета есть каталог `Data`, в нём - подкаталог `String`, а уже в нём лежит модуль `Utils.hs`.

## О лице

У каждого модуля, помимо имени, есть и лицо (или, если угодно, интерфейс). Интерфейс - это набор всего того, что может быть импортировано в другие модули. По умолчанию всё содержимое модуля является его интерфейсом и поэтому доступно всему миру. Однако в реальных модулях у вас, скорее всего, будут некоторые служебные функции и типы, которые вы не захотите показывать всем.

Взглянем ещё раз на начало модуля `Utils.Helpers`:

```haskell
module Utils.Helpers (
    calibrate,
    graduate
) where
```

Вы уже видели такие круглые скобки, теперь же вы знаете, что это и есть интерфейс нашего модуля, поэтому только эти две функции можно будет импортировать. Всё остальное, что есть в этом модуле, останется тайной за семью печатями. В частности, наше служебное значение `coefficient`: при попытке импортировать его в другой модуль компилятор удивлённо упрекнёт вас, мол, не знаю я никакого `coefficient`. Но если оно окажется кому-то нужным - допишем его имя в круглых скобках:

```haskell
module Utils.Helpers (
    calibrate,
    graduate,
    coefficient
) where
```

и всё заработает. Теперь пропишем в лице модуля наш собственный тип:

```haskell
module Utils.Helpers (
    calibrate,
    graduate,
    Color (Red, Green, Blue)
) where

data Color = Red | Green | Blue deriving Show
```

Обратите внимание: недостаточно прописать в лице модуля имя типа, необходимо также перечислить его конструкторы в виде кортежа. Впрочем, достаточно перечислить лишь те конструкторы, которые вы реально собираетесь использовать в других модулях для создания значений типа `Color`.

## Ничего, кроме...

В ряде случаев вам нельзя (или необязательно) импортировать всё то, что есть в модуле. Откроем `app/Main.hs` и напишем в нём:

```haskell
import Utils.Helpers (calibrate)  -- Импортируем только calibrate. 

main :: IO ()
main = print $ calibrate 12.4
```

Мы импортировали лишь то, что перечислено в виде кортежа сразу за именем модуля. Всё остальное содержимое `Utils.Helpers` осталось невидимым.

Вы спросите, зачем это нужно? В конце концов, ну и пусть импортируется всё, а уж мы решим, что нам использовать.

Главная цель частичного импорта - исключение конфликта имён. В разных модулях зачастую присутствуют одноимённые сущности. В этом случае мы можем взять из "конфликтных" модулей только то, что нам необходимо.

## Всё, кроме...

Существует также противоположный подход, а именно частичный импорт всего содержимого модуля, кроме указанного. В этом случае нам понадобится ключевое слово `hiding`:

```haskell
import Utils.Helpers hiding (graduate)  -- graduate скрыта.  
```

После слова `hiding` перечислены в виде кортежа те сущности, которые будут недоступны (скрыты) в текущем модуле. Как вы уже догадались, такой подход так же используется во избежание конфликтов между одноимёнными сущностями из разных модулей.

## Принадлежность

В реальных проектах вы столкнётесь с ситуацией, когда вам очень нужно будет совместно использовать одноимённые функции из разных модулей. Просто так это сделать не получится, компилятор проявит принципиальность и потребует уточнений. В этом случае нам необходимо явно указать принадлежность функции к конкретному модулю:

```haskell
import Utils.Helpers
import Utils.Math  -- А вдруг здесь тоже есть функция calibrate?

main :: IO ()
main = print $ Utils.Helpers.calibrate 12.4
```

В этом случае конфликта не будет.

## Короткая принадлежность

В уже известном нам пакете `MissingH` есть модули с весьма длинным именем, например `System.Console.GetOpt.Utils`. Согласитесь, длинновато писать такой "префикс" всякий раз, когда нужно указать принадлежность. К счастью, есть способ ввести короткий псевдоним для модуля:

```haskell
import Utils.Helpers as H

main :: IO ()
main = print $ H.graduate 23
```

Ключевое слово as вводит короткое имя для `Utils.Helpers`. Кстати, на это имя действует общее для всех типов правило: только с большой буквы. Поэтому такой вариант не пройдёт:

```haskell
import Utils.Helpers as h
```

## Обязательная принадлежность

В ряде случаев бывает полезным призвать пользователя к строгому порядку и обязать его указывать принадлежность сущностей к модулю. Например:

```haskell
import qualified Utils.Helpers as H 

main :: IO ()
main = print $ graduate 23
```

Мы импортировали наш модуль с ключевым словом qualified. Именно поэтому такой код не пройдёт компиляцию. Слово `qualified` обязывает нас уточнять принадлежность всех используемых сущностей к соответствующим им модулям. Поэтому даже если функция graduate представлена в единственном экземпляре, при `qualified`-импорте мы должны явно указать, к какому модулю она принадлежит:

```haskell
print $ H.graduate 23
```

Ну вот, теперь вы знаете о модулях практически всё.











