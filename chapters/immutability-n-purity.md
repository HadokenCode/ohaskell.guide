# Неизменность и чистота

В предыдущей главе мы познакомились с функциями и выражениями, увидев близкую связь этих понятий. В этой главе мы познакомимся с функциями поближе, а также узнаем, что значит &laquo;чисто функциональный&raquo; язык и почему в нём нет места оператору присваивания.

## Объявляем и определяем

Применение функции нам уже знакомо, осталось узнать про объявление и определение, без них использовать функцию не получится. Помните функцию `square`, возводяющую свой единственный аргумент в квадрат? Вот как выглядит её объявление и определение:

```haskell
square :: Int -> Int
square v = v * v
```

Первая строка &mdash; объявление, вторая &mdash; определение. Объявление (англ. declaration) &mdash; это весть всему миру о том, что такая функция существует, вот её имя и вот типы, с которыми она работает. Определение (англ. declaration) &mdash; это &laquo;тело&raquo; функции, её конкретное содержимое.

Рассмотрим объявление:

```haskell
square :: Int -> Int
```

Оно разделено двойным двоеточием на две части: слева указано имя функции, справа &mdash; типы, с которыми эта функция работает, а именно типы аргументов и тип вычисленного, итогового значения. Как вы узнали из предыдущей главы, все данные в Haskell-программе имеют конкретный тип, а поскольку функция работает с данными, её объявление содержит типы этих данных. Типы разделены стрелками. Схематично это выглядит так:

```haskell
square :: Int      -> Int
имя       тип         тип
функции   аргумента   вычисленного
                      значения
```

Такое объявление сообщает нам о том, что функция `square` принимает единственный аргумент типа `Int` и возвращает значение того же типа `Int`. Если же аргументов более одного, объявление просто вытягивается. Например, объявление функции `product`, возвращающей произведение двух целочисленных аргументов, могло бы выглядеть так:

```haskell
product :: Int      -> Int      -> Int
имя        тип         тип         тип
функции    первого     второго     вычисленного
           аргумента   аргумента   значения
```

Идею вы поняли: ищем крайнюю правую стрелку, и всё что левее от неё &mdash; то типы аргументов, а всё что правее &mdash; то тип вычисленного значения.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
Мы не можем работать с функцией, которая ничего не вычисляет. То есть аналога C-функции `void f(int i)` в Haskell быть не может, так как это противоречит математической природе. Однако мы можем работать с функцией, которая ничего не принимает, то есть с аналогом `int f(void)`. С такими функциями мы познакомимся в следующих главах.
</span></div>

Теперь рассмотрим определение функции `square`:

```haskell
square v = v * v
```

Схема определения такова:

```haskell
square   v          =    v * v
имя      имя        это  выражение
функции  аргумента
```

А функция `product` определена так:

```haskell
product  x          y         =    x * y
имя      имя        имя       это  выражение
функции  первого    второго
         аргумента  аргумента
```

Определение тоже разделено на две части: слева от знака равенства &mdash; имя функции и имена аргументов (уже имена, а не типы), разделённые пробелами, а справа &mdash; выражение, составляющее суть функции, её содержимое. В C-подобных языках закрепилось понятие &laquo;тело функции&raquo; (англ. function body), однако в Haskell чаще говорят о выражении.

Обратите внимание, речь здесь идёт именно о знаке равенства, а никак не об операторе присваивания. Мы ничего не присваиваем, мы лишь декларируем равенство левой и правой частей. Когда мы пишем:

```haskell
product x y = x * y
```

мы объявляем следующее: &laquo;Отныне выражение `product 2 5` равно выражению `2 * 5`&raquo;. Мы можем безопасно заменить выражение `product 2 5` выражением `2 * 5`, а выражение `product 120 500` &mdash; выражением `120 * 500`, и при всём при этом работа программы гарантированно останется неизменной.

Но откуда у меня такая уверенность? А вот откуда.

## Чисто функциональный

Haskell &mdash; чисто функциональный (англ. purely functional) язык. Чисто функциональным называется такой язык, в котором центральное место уделено чистой функции (англ. pure function). А чистой она называется потому, что предельно честна с нами: её выходное значение всецело определяется её аргументами и более ничем. А ведь это и есть математическая функция, вспомним ту же `product`: когда на входе числа `10` и `20` &mdash; на выходе будет всегда `200`, и ничто не способно помешать этому. Функция `product` является чистой, а потому характеризуется отсутствием побочных эффектов (англ. side effects): она не способна сделать ничего, кроме как вернуть нам произведение двух своих аргументов. Именно поэтому чистая функция предельно надёжна и не может преподнести нам никаких сюрпризов.

Скажу больше: чистая функция не видит окружающий мир. Вообще. Причём в данном случае под &laquo;окружающим миром&raquo; я подразумеваю не только внешний по отношению ко всей программе мир (например, файловая система или сеть), но и все остальные функции. Чистую функцию можно сравнить с чёрным ящиком: она знает только свои аргументы и вычисляемое ею значение. Это даёт нам второе преимущество чистых функций &mdash; компонуемость. Раз функции полностью изолированы друг от друга, их очень просто комбинировать, строя из более простых более сложные.

<div class="card-panel orange darken-2 left-align smaller-text"><span class="white-text">
И раз уж я упомянул об этом вскользь, подчеркну: чистые функции не способны взаимодействовать с внешним по отношению к программе миром. Они не могут вывести текст на консоль, их нельзя заставить обработать HTTP-запрос, они не умеют дружить с базой данных. Они суть вещь в себе.
</span></div>

И чтобы удивить вас ещё больше, открою очередной секрет Haskell.

## &laquo;Присваивание? Не, не слышал&hellip;&raquo;

В мире Haskell нет места оператору присваивания. Впрочем, этот факт удивителен лишь на первый взгляд. Задумаемся: раз уж каждая функция в конечном итоге представляет собою выражение, вычисляемое посредством применения каких-то других функций к каким-то другим аргументам, тогда нам просто не нужно ничего ничему присваивать.

Вспомним, что присваивание (англ. assignment) пришло к нам из императивных языков. При императивном программировании (англ. imperative programming) программа воспринимается как набор инструкций, выполнение которых неразрывно связано с изменением состояния этой программы. Вот почему в императивных языках присутствует понятие &laquo;переменная&raquo; (англ. variable). А раз есть переменные &mdash; должен быть и инструмент для изменения их конкретных значений, а именно оператор присваивания. Когда мы пишем:

```c
coeff = 0.569;
```

мы тем самым приказываем: &laquo;Возьми значение `0.569` и перезапиши им то значение, которое уже содержалось в переменной `coeff` до этого&raquo;. И перезаписывать это значение мы можем множество раз, а следовательно, мы вынуждены внимательно отслеживать текущее состояние переменной `coeff`, равно как и всех остальных переменных в нашем коде.

Однако существует принципиально иной подход к разработке, а именно декларативное программирование (англ. declarative programming). Haskell воплотил в себе именно этот подход, при котором программа воспринимается уже не как набор инструкций, а как набор выражений. А поскольку выражения вычисляются путём применения функций к аргументам (то есть, по сути, к другим выражениям), там нет места ни переменным, ни оператору присваивания. Все данные в Haskell-программе, будучи созданными единожды, уже не могут быть изменены. Поэтому когда в Haskell-коде мы пишем:

```haskell
coeff = 0.569;
```

мы просто объявляем: &laquo;Отныне значение `coeff` равно `0.569`, и так оно будет всегда&raquo;. Вот почему в Haskell-коде символ `=` &mdash; это знак равенства, а вовсе не присваивание.

## Удивлены?

Полагаю, да. Как же можно написать реальную программу на языке, в котором нельзя изменять данные? Какой прок от этих чистых функций, если они не способны ни файл прочесть, ни запрос по сети отправить? Оказывается, прок есть, и на Haskell можно написать очень даже реальную программу. За примером далеко ходить не буду: сама эта книга построена с помощью Haskell, о чём я подробнее расскажу в следующих главах.

А теперь, дабы не мучить вас вопросами без ответов, мы начнём ближе знакомится с Китами Haskell, и детали большой головоломки постепенно сложатся в красивую картину. Погрузимся в функцию.

