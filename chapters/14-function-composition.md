# Композиция функций

Эта глава рассказывает о том, как объединять функции в цепочки, а также о том, как избавиться от круглых скобок.

## Скобкам &mdash; бой!

При всём уважении к Lisp-программистам, я не люблю круглые скобки. Они делают код визуально избыточным, к тому же нужно следить за симметрией скобок открывающих и закрывающих. Вспомним пример из главы про кортежи:

```haskell
main :: IO ()
main =
  putStrLn (patientEmail ( "63ab89d"
           ^             , "John Smith"
                         , "johnsm@gmail.com"
                         , 59
                         ))
                          ^
```

Со скобками кортежа мы ничего не можем сделать, ведь они являются частью кортежа. А вот скобки вокруг применения функции `patientEmail` мне абсолютно не нравятся. К счастью, мы можем избавиться от них. Но прежде чем искоренять скобки, задумаемся вот о чём.

Если применение функции представляет собой выражение, не можем ли мы как-нибудь компоновать их друг с другом? Конечно можем, мы уже делали это много раз, вспомните:

```haskell
main :: IO ()
main = putStrLn (checkLocalhost "173.194.22.100")
```

Здесь компонуются две функции, `putStrLn` и `checkLocalhost`, потому что тип выражения на выходе функции `checkLocalhost`, совпадает с типом выражения на входе функции `putStrLn`. Схематично это можно изобразить так:

```haskell
         +----------------+            +----------+
String ->| checkLocalhost |-> String ->| putStrLn |-> ...
         +----------------+            +----------+
```

Получается эдакий конвейер: на входе строка с IP-адресом, на выходе &mdash; сообщение в нашем терминале. Сущестует более лаконичный способ соединения двух функций воедино.

## Композиция и применение

Взгляните:

```haskell
main :: IO ()
main = putStrLn . checkLocalhost $ "173.194.22.100"
```

Необычно? Перед нами два новых стандартных оператора, избавляющие нас от лишних скобок и делающие наш код проще. Оператор `.` &mdash; это оператор композиции функций (англ. function composition), а оператор `$` &mdash; это оператор применения (англ. application operator). Эти операторы часто используют совместно друг с другом.

Оператор композиции объединяет две функции воедино (или компонует их, англ. compose). Когда мы пишем:

```haskell
putStrLn . checkLocalhost
```

происходит маленькая &laquo;магия&raquo;: две функции объединяются в новую функцию. Вспомним наш конвейер:

```haskell
         +----------------+            +----------+
String ->| checkLocalhost |-> String ->| putStrLn |-> ...
         +----------------+            +----------+

A                             B                       C
```

Раз нам нужно попасть из точки `A` в точку `C`, нельзя ли сделать это сразу? Можно, и в этом заключается суть композиции: мы берём две функции и объединяем их в третью функцию. Раз `checkLocalhost` приводит нас из точки `A` в `B`, а `putStrLn` &mdash; из точки `B` в `C`, то композиция этих двух функций будет представлять собой функцию, приводящую нас сразу из `A` в `C`:

```haskell
         +---------------------------+
String ->| checkLocalhost + putStrLn |-> ...
         +---------------------------+

A                                        C
```

В данном случае знак `+` не относится к конкретному оператору, я лишь показываю факт &laquo;объединения&raquo; двух функций в третью. Разумеется, промежуточная точка `B` никуда не исчезла, просто она теперь скрыта от наших глаз.

И теперь нам стало понятнее, почему в типе функции, в качестве разделителя, используется стрелка:

```haskell
checkLocalhost :: String -> String

в нашем примере это:

checkLocalhost :: A      -> B
```

Она показывает наше движение, из точки `A` в точку `B`. Поэтому часто говорят о &laquo;функции из `A` в `B`&raquo;. Так, о функции `checkLocalhost` можно сказать как о &laquo;функции из `String` в `String`&raquo;.

А оператор применения работает ещё проще. Без него код был бы таким:

```haskell
main :: IO ()
main =
  (putStrLn . checkLocalhost)  "173.194.22.100"

  объединённая функция         аргумент
```

Но мы ведь хотели избавиться от круглых скобок, а тут они опять. Вот для этого и нужен оператор применения:

```haskell
main :: IO ()
main =
  putStrLn . checkLocalhost  $              "173.194.22.100"

  объединённая функция       применяется к  аргументу
```

Теперь получился настоящий конвейер: справа в него &laquo;заезжает&raquo; строка и едет &laquo;сквозь&raquo; функции, а слева &laquo;выезжает&raquo; результат:

```haskell
main = putStrLn . checkLocalhost $  "173.194.22.100"

       <-       <-               <- аргумент
```

Чтобы было легче читать композицию, вместо оператора `.` мысленно подставляем фразу &laquo;применяется после&raquo;:

```haskell
putStrLn  .            checkLocalhost

эта       применяется  этой
функция   после        функции
```

То есть композиция правоассоциативна: сначала применяется функция справа, а затем &mdash; слева. Красота композиции в том, что компоновать мы можем сколько угодно функций:

```haskell
logWarn :: String -> String
logWarn rawMessage =
  warning . correctSpaces . asciiOnly $ rawMessage

main :: IO ()
main = putStrLn $ logWarn "Province   'Gia Viễn' isn't on the map! "
```

Функция `logWarn` готовит переданную ей строку для записи в журнал. Функция `asciiOnly` готовит строку к выводу в нелокализованном терминале, функция `correctSpaces` убирает дублирующиеся пробелы, а функция `warning` делает строку предупреждением (например, добавляет строку "WARNING: " в начало сообщения). Таким образом, при запуске этой программы мы увидим:

```bash
WARNING: Province 'Gia Vi?n' isn't on the map!
```

Здесь мы объединили в &laquo;функциональный конвейер&raquo; уже три функции, безо всяких скобок. Более того, определение функции `logWarn` можно сделать ещё более простым:

```haskell
logWarn :: String -> String
logWarn = warning . correctSpaces . asciiOnly
```

Погодите, но где же имя аргумента? Его больше нет, оно нам не нужно. Вспомните, что применение функции может быть легко заменено внутренним выражением функции. А раз так, выражение `logWarn` может быть заменено на выражение `warning . correctSpaces . asciiOnly`. Сделаем же это:

```haskell
logWarn "Province   'Gia Viễn' isn't on the map! " =
(warning
 . correctSpaces
 . asciiOnly) "Province   'Gia Viễn' isn't on the map! " =
warning
. correctSpaces
. asciiOnly $ "Province   'Gia Viễn' isn't on the map! "
```

И всё работает! В мире Haskell принято именно так: если что-то может быть упрощено &mdash; мы это упрощаем.

## Как работает композиция

Если вдруг вы подумали, что оператор композиции уникален и встроен в Haskell &mdash; спешу вас разочаровать. Никакой магии, всё предельно просто. Этот оператор определён так же, как любая другая функция. Вот его определение:

```haskell
(.) f g = \x -> f (g x)
```

Опа! Да тут и вправду нет ничего особенного. Оператор композиции применяется к двум функциям. Стоп, скажете вы, как это? Применяется к функциям?? Да, именно так. Ведь мы уже выяснили, что функциями можно оперировать как данными. А раз так, что нам мешает передать функцию в качестве аргумента другой функции? Что нам мешает вернуть функцию из другой функции? Ничего.

Оператор композиции получает на вход две функции, а потом всего лишь даёт нам ЛФ, внутри которой происходит обыкновенный последовательный вызов этих двух функций через скобки. И никакой магии:

```haskell
(.)    f        g        =  \x -> f (g x)

берём  эту      и эту       и возвращаем
       функцию  функцию     ЛФ, внутри
                            которой
                            вызываем их
```

Подставим наши функции:

```haskell
(.) putStrLn checkLocalhost = \x -> putStrLn (checkLocalhost x)
```

Вот так и происходит &laquo;объединение&raquo; функций: мы просто возвращаем ЛФ от одного аргумента, внутри которой правоассоциативно вызываем обе функции. А аргументом и является та самая строка с IP-адресом:

```haskell
(\x -> putStrLn (checkLocalhost x)) "173.194.22.100" =
putStrLn (checkLocalhost "173.194.22.100"))
```

Теперь мы видим, что в композиции функций нет ничего сверхъестественного. Эту мысль я подчёркиваю на протяжении всей книги: в Haskell нет никакой магии, он логичен и последователен.

